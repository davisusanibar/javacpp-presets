// Targeted by JavaCPP version 1.5.9-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.arrow;

import org.bytedeco.arrow.Function;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

import static org.bytedeco.arrow.global.arrow.*;


/** A utility which keeps tracks of, and schedules, asynchronous tasks
 * 
 *  An asynchronous task has a synchronous component and an asynchronous component.
 *  The synchronous component typically schedules some kind of work on an external
 *  resource (e.g. the I/O thread pool or some kind of kernel-based asynchronous
 *  resource like io_uring).  The asynchronous part represents the work
 *  done on that external resource.  Executing the synchronous part will be referred
 *  to as "submitting the task" since this usually includes submitting the asynchronous
 *  portion to the external thread pool.
 * 
 *  By default the scheduler will submit the task (execute the synchronous part) as
 *  soon as it is added, assuming the underlying thread pool hasn't terminated or the
 *  scheduler hasn't aborted.  In this mode, the scheduler is simply acting as
 *  a simple task group.
 * 
 *  A task scheduler starts with an initial task.  That task, and all subsequent tasks
 *  are free to add subtasks.  Once all submitted tasks finish the scheduler will
 *  finish.  Note, it is not an error to add additional tasks after a scheduler has
 *  aborted. These tasks will be ignored and never submitted.  The scheduler returns a
 *  future which will complete when all submitted tasks have finished executing.  Once all
 *  tasks have been finsihed the scheduler is invalid and should no longer be used.
 * 
 *  Task failure (either the synchronous portion or the asynchronous portion) will cause
 *  the scheduler to enter an aborted state.  The first such failure will be reported in
 *  the final task future. */
@Namespace("arrow::util") @Properties(inherit = org.bytedeco.arrow.presets.arrow.class)
public class AsyncTaskScheduler extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AsyncTaskScheduler(Pointer p) { super(p); }

  /** Destructor for AsyncTaskScheduler
   * 
   *  The lifetime of the task scheduled is managed automatically.  The scheduler
   *  will remain valid while any tasks are running (and can always be safely accessed)
   *  within tasks) and will be destroyed as soon as all tasks have finished. */
  /** An interface for a task
   * 
   *  Users may want to override this, for example, to add priority
   *  information for use by a queue. */
  public static class Task extends Pointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public Task(Pointer p) { super(p); }
  
    /** Submit the task
     * 
     *  This will be called by the scheduler at most once when there
     *  is space to run the task.  This is expected to be a fairly quick
     *  function that simply submits the actual task work to an external
     *  resource (e.g. I/O thread pool).
     * 
     *  If this call fails then the scheduler will enter an aborted state. */
    
    ///
    public native @ByVal @Name("operator ()") FutureResult apply();
    /** The cost of the task
     * 
     *  A ThrottledAsyncTaskScheduler can be used to limit the number of concurrent tasks.
     *  A custom cost may be used, for example, if you would like to limit the number of
     *  tasks based on the total expected RAM usage of the tasks (this is done in the
     *  scanner) */
    public native int cost();
  }

  /** Add a task to the scheduler
   * 
   *  If the scheduler is in an aborted state this call will return false and the task
   *  will never be run.  This is harmless and does not need to be guarded against.
   * 
   *  The return value for this call can usually be ignored.  There is little harm in
   *  attempting to add tasks to an aborted scheduler.  It is only included for callers
   *  that want to avoid future task generation to save effort.
   * 
   *  @param task the task to submit
   * 
   *  @return true if the task was submitted or queued, false if the task was ignored */
  
  ///
  ///
  ///
  ///
  public native @Cast("bool") boolean AddTask(@UniquePtr Task task);

  /** Adds an async generator to the scheduler
   * 
   *  The async generator will be visited, one item at a time.  Submitting a task
   *  will consist of polling the generator for the next future.  The generator's future
   *  will then represent the task itself.
   * 
   *  This visits the task serially without readahead.  If readahead or parallelism
   *  is desired then it should be added in the generator itself.
   * 
   *  The generator itself will be kept alive until all tasks have been completed.
   *  However, if the scheduler is aborted, the generator will be destroyed as soon as the
   *  next item would be requested.
   * 
   *  @param generator the generator to submit to the scheduler
   *  @param visitor a function which visits each generator future as it completes */

  /** Add a task with cost 1 to the scheduler
   * 
   *  @see AddTask for details */

  /** Construct a scheduler
   * 
   *  @param initial_task The initial task which is responsible for adding
   *         the first subtasks to the scheduler.
   *  @param abort_callback A callback that will be triggered immediately after a task
   *         fails while other tasks may still be running.  Nothing needs to be done here,
   *         when a task fails the scheduler will stop accepting new tasks and eventually
   *         return the error.  However, this callback can be used to more quickly end
   *         long running tasks that have already been submitted.  Defaults to doing
   *         nothing.
   *  @param stop_token An optional stop token that will allow cancellation of the
   *         scheduler.  This will be checked before each task is submitted and, in the
   *         event of a cancellation, the scheduler will enter an aborted state. This is
   *         a graceful cancellation and submitted tasks will still complete.
   *  @return A future that will be completed when the initial task and all subtasks have
   *          finished. */
}
