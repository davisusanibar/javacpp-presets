// Targeted by JavaCPP version 1.5.9-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.arrow;

import org.bytedeco.arrow.Function;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

import static org.bytedeco.arrow.global.arrow.*;


/** \brief Base class for all data types
 * 
 *  Data types in this library are all *logical*. They can be expressed as
 *  either a primitive physical type (bytes or bits of some fixed size), a
 *  nested type consisting of other data types, or another data type (e.g. a
 *  timestamp encoded as an int64).
 * 
 *  Simple datatypes may be entirely described by their Type::type id, but
 *  complex datatypes are usually parametric. */
@Namespace("arrow") @NoOffset @Properties(inherit = org.bytedeco.arrow.presets.arrow.class)
public class DataType extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DataType(Pointer p) { super(p); }
    public Fingerprintable asFingerprintable() { return asFingerprintable(this); }
    @Namespace public static native @Name("static_cast<arrow::detail::Fingerprintable*>") Fingerprintable asFingerprintable(DataType pointer);


  /** \brief Return whether the types are equal
   * 
   *  Types that are logically convertible from one to another (e.g. List<UInt8>
   *  and Binary) are NOT equal. */
  public native @Cast("bool") boolean Equals(@Const @ByRef DataType other, @Cast("bool") boolean check_metadata/*=false*/);
  public native @Cast("bool") boolean Equals(@Const @ByRef DataType other);

  /** \brief Return whether the types are equal */

  /** \brief Return the child field at index i. */
  public native @SharedPtr @Cast({"", "std::shared_ptr<arrow::Field>"}) Field field(int i);

  /** \brief Return the children fields associated with this type. */
  public native @Const @ByRef FieldVector fields();

  /** \brief Return the number of children fields associated with this type. */
  public native int num_fields();

  /** \brief Apply the TypeVisitor::Visit() method specialized to the data type */
  public native @ByVal Status Accept(TypeVisitor visitor);

  /** \brief A string representation of the type, including any children */
  public native @StdString String ToString();

  /** \brief Return hash value (excluding metadata in child fields) */
  
  ///
  public native @Cast("size_t") long Hash();

  /** \brief A string name of the type, omitting any child fields
   * 
   *  @since 0.7.0 */
  
  ///
  public native @StdString String name();

  /** \brief Return the data type layout.  Children are not included.
   * 
   *  \note Experimental API */
  public native @ByVal DataTypeLayout layout();

  /** \brief Return the type category */
  public native @Cast("arrow::Type::type") int id();

  /** \brief Return the type category of the storage type */
  public native @Cast("arrow::Type::type") int storage_id();

  /** \brief Returns the type's fixed byte width, if any. Returns -1
   *  for non-fixed-width types, and should only be used for
   *  subclasses of FixedWidthType */
  public native int byte_width();

  /** \brief Returns the type's fixed bit width, if any. Returns -1
   *  for non-fixed-width types, and should only be used for
   *  subclasses of FixedWidthType */
  public native int bit_width();

  // \brief EXPERIMENTAL: Enable retrieving shared_ptr<DataType> from a const
  // context.
  public native @SharedPtr @Cast({"", "std::shared_ptr<arrow::DataType>"}) DataType GetSharedPtr();
}
