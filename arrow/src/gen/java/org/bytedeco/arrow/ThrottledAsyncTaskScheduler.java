// Targeted by JavaCPP version 1.5.9-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.arrow;

import org.bytedeco.arrow.Function;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

import static org.bytedeco.arrow.global.arrow.*;


@Namespace("arrow::util") @Properties(inherit = org.bytedeco.arrow.presets.arrow.class)
public class ThrottledAsyncTaskScheduler extends AsyncTaskScheduler {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ThrottledAsyncTaskScheduler(Pointer p) { super(p); }

  /** An interface for a task queue
   * 
   *  A queue's methods will not be called concurrently */
  public static class Queue extends Pointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public Queue(Pointer p) { super(p); }
  
    /** Push a task to the queue
     * 
     *  @param task the task to enqueue */
    public native void Push(@UniquePtr Task task);
    /** Pop the next task from the queue */
    public native @UniquePtr Task Pop();
    /** Peek the next task in the queue */
    public native @Const @ByRef Task Peek();
    /** Check if the queue is empty */
    public native @Cast("bool") boolean Empty();
    /** Purge the queue of all items */
    public native void Purge();
  }

  public static class Throttle extends Pointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public Throttle(Pointer p) { super(p); }
  
    /** Acquire amt permits
     * 
     *  If nullopt is returned then the permits were immediately
     *  acquired and the caller can proceed.  If a future is returned then the caller
     *  should wait for the future to complete first.  When the returned future completes
     *  the permits have NOT been acquired and the caller must call Acquire again
     * 
     *  @param amt the number of permits to acquire */
    
    ///
    ///
    public native @Optional Future TryAcquire(int amt);
    /** Release amt permits
     * 
     *  This will possibly complete waiting futures and should probably not be
     *  called while holding locks.
     * 
     *  @param amt the number of permits to release */
    
    ///
    public native void Release(int amt);

    /** The size of the largest task that can run
     * 
     *  Incoming tasks will have their cost latched to this value to ensure
     *  they can still run (although they will be the only thing allowed to
     *  run at that time). */
    
    ///
    public native int Capacity();

    /** Pause the throttle
     * 
     *  Any tasks that have been submitted already will continue.  However, no new tasks
     *  will be run until the throttle is resumed. */
    
    ///
    public native void Pause();
    /** Resume the throttle
     * 
     *  Allows taks to be submitted again.  If there is a max_concurrent_cost limit then
     *  it will still apply. */
    public native void Resume();
  }

  /** Pause the throttle
   * 
   *  Any tasks that have been submitted already will continue.  However, no new tasks
   *  will be run until the throttle is resumed. */
  
  ///
  public native void Pause();
  /** Resume the throttle
   * 
   *  Allows taks to be submitted again.  If there is a max_concurrent_cost limit then
   *  it will still apply. */
  
  ///
  ///
  ///
  ///
  ///
  ///
  ///
  ///
  public native void Resume();

  /** Create a throttled view of a scheduler
   * 
   *  Tasks added via this view will be subjected to the throttle and, if the tasks cannot
   *  run immediately, will be placed into a queue.
   * 
   *  Although a shared_ptr is returned it should generally be assumed that the caller
   *  is being given exclusive ownership.  The shared_ptr is used to share the view with
   *  queued and submitted tasks and the lifetime of those is unpredictable.  It is
   *  important the caller keep the returned pointer alive for as long as they plan to add
   *  tasks to the view.
   * 
   *  @param scheduler a scheduler to submit tasks to after throttling
   * 
   *  This can be the root scheduler, another throttled scheduler, or a task group.  These
   *  are all composable.
   * 
   *  @param max_concurrent_cost the maximum amount of cost allowed to run at any one time
   * 
   *  If a task is added that has a cost greater than max_concurrent_cost then its cost
   *  will be reduced to max_concurrent_cost so that it is still possible for the task to
   *  run.
   * 
   *  @param queue the queue to use when tasks cannot be submitted
   * 
   *  By default a FIFO queue will be used.  However, a custom queue can be provided if
   *  some tasks have higher priority than other tasks. */
  
  ///
  public static native @SharedPtr ThrottledAsyncTaskScheduler Make(
        AsyncTaskScheduler scheduler, int max_concurrent_cost,
        @UniquePtr Queue queue/*=nullptr*/);
  public static native @SharedPtr ThrottledAsyncTaskScheduler Make(
        AsyncTaskScheduler scheduler, int max_concurrent_cost);

  /** \brief Create a ThrottledAsyncTaskScheduler using a custom throttle
   * 
   *  @see Make */
  public static native @SharedPtr ThrottledAsyncTaskScheduler MakeWithCustomThrottle(
        AsyncTaskScheduler scheduler, @UniquePtr Throttle throttle,
        @UniquePtr Queue queue/*=nullptr*/);
  public static native @SharedPtr ThrottledAsyncTaskScheduler MakeWithCustomThrottle(
        AsyncTaskScheduler scheduler, @UniquePtr Throttle throttle);
}
