// Targeted by JavaCPP version 1.5.9-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.arrow;

import org.bytedeco.arrow.Function;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

import static org.bytedeco.arrow.global.arrow.*;


/** A utility to keep track of a collection of tasks
 * 
 *  Often it is useful to keep track of some state that only needs to stay alive
 *  for some small collection of tasks, or to perform some kind of final cleanup
 *  when a collection of tasks is finished.
 * 
 *  For example, when scanning, we need to keep the file reader alive while all scan
 *  tasks run for a given file, and then we can gracefully close it when we finish the
 *  file. */
@Namespace("arrow::util") @Properties(inherit = org.bytedeco.arrow.presets.arrow.class)
public class AsyncTaskGroup extends AsyncTaskScheduler {
    static { Loader.load(); }
    /** Default native constructor. */
    public AsyncTaskGroup() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public AsyncTaskGroup(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AsyncTaskGroup(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public AsyncTaskGroup position(long position) {
        return (AsyncTaskGroup)super.position(position);
    }
    @Override public AsyncTaskGroup getPointer(long i) {
        return new AsyncTaskGroup((Pointer)this).offsetAddress(i);
    }

  /** Destructor for the task group
   * 
   *  The destructor might trigger the finish callback.  If the finish callback fails
   *  then the error will be reported as a task on the scheduler.
   * 
   *  Failure to destroy the async task group will not prevent the scheduler from
   *  finishing.  If the scheduler finishes before the async task group is done then
   *  the finish callback will be run immediately when the async task group finishes.
   * 
   *  If the scheduler has aborted then the finish callback will not run. */
  /** Create an async task group
   * 
   *  The finish callback will not run until the task group is destroyed and all
   *  tasks are finished so you will generally want to reset / destroy the returned
   *  unique_ptr at some point.
   * 
   *  @param scheduler The underlying scheduler to submit tasks to
   *  @param finish_callback A callback that will be run only after the task group has
   *                         been destroyed and all tasks added by the group have
   *                         finished.
   * 
   *  Note: in error scenarios the finish callback may not run.  However, it will still,
   *  of course, be destroyed. */
}
