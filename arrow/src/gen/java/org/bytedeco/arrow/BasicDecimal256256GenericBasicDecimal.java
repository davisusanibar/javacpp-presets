// Targeted by JavaCPP version 1.5.9-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.arrow;

import org.bytedeco.arrow.Function;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

import static org.bytedeco.arrow.global.arrow.*;


@Name("arrow::GenericBasicDecimal<arrow::BasicDecimal256,256>") @NoOffset @Properties(inherit = org.bytedeco.arrow.presets.arrow.class)
public class BasicDecimal256256GenericBasicDecimal extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public BasicDecimal256256GenericBasicDecimal(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public BasicDecimal256256GenericBasicDecimal(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public BasicDecimal256256GenericBasicDecimal position(long position) {
        return (BasicDecimal256256GenericBasicDecimal)super.position(position);
    }
    @Override public BasicDecimal256256GenericBasicDecimal getPointer(long i) {
        return new BasicDecimal256256GenericBasicDecimal((Pointer)this).offsetAddress(i);
    }

  @MemberGetter public static native int kBitWidth();
  public static final int kBitWidth = kBitWidth();
  @MemberGetter public static native int kByteWidth();
  public static final int kByteWidth = kByteWidth();

  // A constructor tag to introduce a little-endian encoded array

  /** \brief Empty constructor creates a decimal with a value of 0. */
  
  ///
  public BasicDecimal256256GenericBasicDecimal() { super((Pointer)null); allocate(); }
  @NoException(true) private native void allocate();

  /** \brief Create a decimal from the two's complement representation.
   * 
   *  Input array is assumed to be in native endianness. */
  
  ///
  public BasicDecimal256256GenericBasicDecimal(
        @Cast("const arrow::GenericBasicDecimal<arrow::BasicDecimal256,256>::WordArray*") @ByRef Byte16Array array) { super((Pointer)null); allocate(array); }
  @NoException(true) private native void allocate(
        @Cast("const arrow::GenericBasicDecimal<arrow::BasicDecimal256,256>::WordArray*") @ByRef Byte16Array array);

  /** \brief Create a decimal from the two's complement representation.
   * 
   *  Input array is assumed to be in little endianness, with native endian elements. */

  /** \brief Create a decimal from an array of bytes.
   * 
   *  Bytes are assumed to be in native-endian byte order. */
  
  ///
  public BasicDecimal256256GenericBasicDecimal(@Cast("const uint8_t*") BytePointer bytes) { super((Pointer)null); allocate(bytes); }
  private native void allocate(@Cast("const uint8_t*") BytePointer bytes);
  public BasicDecimal256256GenericBasicDecimal(@Cast("const uint8_t*") ByteBuffer bytes) { super((Pointer)null); allocate(bytes); }
  private native void allocate(@Cast("const uint8_t*") ByteBuffer bytes);
  public BasicDecimal256256GenericBasicDecimal(@Cast("const uint8_t*") byte[] bytes) { super((Pointer)null); allocate(bytes); }
  private native void allocate(@Cast("const uint8_t*") byte[] bytes);

  /** \brief Get the bits of the two's complement representation of the number.
   * 
   *  The elements are in native endian order. The bits within each uint64_t element
   *  are in native endian order. For example, on a little endian machine,
   *  BasicDecimal128(123).native_endian_array() = {123, 0};
   *  but on a big endian machine,
   *  BasicDecimal128(123).native_endian_array() = {0, 123}; */
  
  ///
  public native @Cast("const arrow::GenericBasicDecimal<arrow::BasicDecimal256,256>::WordArray*") @ByRef Byte16Array native_endian_array();

  /** \brief Get the bits of the two's complement representation of the number.
   * 
   *  The elements are in little endian order. However, the bits within each
   *  uint64_t element are in native endian order.
   *  For example, BasicDecimal128(123).little_endian_array() = {123, 0}; */
  public native @ByVal @Cast("arrow::GenericBasicDecimal<arrow::BasicDecimal256,256>::WordArray*") Byte16Array little_endian_array();

  public native @Cast("const uint8_t*") BytePointer native_endian_bytes();

  public native @Cast("uint8_t*") BytePointer mutable_native_endian_bytes();

  /** \brief Return the raw bytes of the value in native-endian byte order. */

  /** \brief Copy the raw bytes of the value in native-endian byte order. */
  public native void ToBytes(@Cast("uint8_t*") BytePointer out);
  public native void ToBytes(@Cast("uint8_t*") ByteBuffer out);
  public native void ToBytes(@Cast("uint8_t*") byte[] out);

  /** Return 1 if positive or zero, -1 if strictly negative. */
  public native @Cast("int64_t") long Sign();

  public native @Cast("bool") boolean IsNegative();
}
