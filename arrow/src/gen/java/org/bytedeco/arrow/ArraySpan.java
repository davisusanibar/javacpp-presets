// Targeted by JavaCPP version 1.5.9-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.arrow;

import org.bytedeco.arrow.Function;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

import static org.bytedeco.arrow.global.arrow.*;


/** \brief EXPERIMENTAL: A non-owning ArrayData reference that is cheaply
 *  copyable and does not contain any shared_ptr objects. Do not use in public
 *  APIs aside from compute kernels for now */
@Namespace("arrow") @NoOffset @Properties(inherit = org.bytedeco.arrow.presets.arrow.class)
public class ArraySpan extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ArraySpan(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ArraySpan(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public ArraySpan position(long position) {
        return (ArraySpan)super.position(position);
    }
    @Override public ArraySpan getPointer(long i) {
        return new ArraySpan((Pointer)this).offsetAddress(i);
    }

  public native @Const DataType type(); public native ArraySpan type(DataType setter);
  public native @Cast("int64_t") long length(); public native ArraySpan length(long setter);
  public native @Cast("int64_t") long null_count(); public native ArraySpan null_count(long setter);
  public native @Cast("int64_t") long offset(); public native ArraySpan offset(long setter);
  public native @ByRef BufferSpan buffers(int i); public native ArraySpan buffers(int i, BufferSpan setter);
  @MemberGetter public native BufferSpan buffers();

  // 16 bytes of scratch space to enable this ArraySpan to be a view onto
  // scalar values including binary scalars (where we need to create a buffer
  // that looks like two 32-bit or 64-bit offsets)
  public native @Cast("uint64_t") long scratch_space(int i); public native ArraySpan scratch_space(int i, long setter);
  @MemberGetter public native @Cast("uint64_t*") LongPointer scratch_space();

  public ArraySpan() { super((Pointer)null); allocate(); }
  private native void allocate();

  public ArraySpan(@Const DataType type, @Cast("int64_t") long length) { super((Pointer)null); allocate(type, length); }
  private native void allocate(@Const DataType type, @Cast("int64_t") long length);

  public ArraySpan(@Const @ByRef ArrayData data) { super((Pointer)null); allocate(data); }
  private native void allocate(@Const @ByRef ArrayData data);
  public ArraySpan(@Const @ByRef Scalar data) { super((Pointer)null); allocate(data); }
  private native void allocate(@Const @ByRef Scalar data);

  /** If dictionary-encoded, put dictionary in the first entry */
  public native @StdVector ArraySpan child_data(); public native ArraySpan child_data(ArraySpan setter);

  /** \brief Populate ArraySpan to look like an array of length 1 pointing at
   *  the data members of a Scalar value */
  public native void FillFromScalar(@Const @ByRef Scalar value);

  public native void SetMembers(@Const @ByRef ArrayData data);

  public native void SetBuffer(int index, @SharedPtr ArrowBuffer buffer);

  public native @Const @ByRef ArraySpan dictionary();

  /** \brief Return the number of buffers (out of 3) that are used to
   *  constitute this array */
  public native int num_buffers();

  // Access a buffer's data as a typed C pointer

  // Access a buffer's data as a typed C pointer

  public native @Cast("bool") boolean IsValid(@Cast("int64_t") long i);

  public native @Cast("bool") boolean IsNull(@Cast("int64_t") long i);

  public native @SharedPtr @Cast({"", "std::shared_ptr<arrow::ArrayData>"}) ArrayData ToArrayData();

  public native @SharedPtr @Cast({"", "std::shared_ptr<arrow::Array>"}) Array ToArray();

  public native @SharedPtr ArrowBuffer GetBuffer(int index);

  public native void SetSlice(@Cast("int64_t") long offset, @Cast("int64_t") long length);

  /** \brief Return null count, or compute and set it if it's not known */
  public native @Cast("int64_t") long GetNullCount();

  public native @Cast("bool") boolean MayHaveNulls();
}
