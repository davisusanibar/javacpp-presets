// Targeted by JavaCPP version 1.5.9-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.arrow;

import org.bytedeco.arrow.Function;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

import static org.bytedeco.arrow.global.arrow.*;


/** \brief Container to capture both exact and input-dependent output types. */
@Namespace("arrow::compute") @NoOffset @Properties(inherit = org.bytedeco.arrow.presets.arrow.class)
public class OutputType extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OutputType(Pointer p) { super(p); }

  /** \brief An enum indicating whether the value type is an invariant fixed
   *  value or one that's computed by a kernel-defined resolver function. */
  public enum ResolveKind { FIXED(0), COMPUTED(1);

      public final int value;
      private ResolveKind(int v) { this.value = v; }
      private ResolveKind(ResolveKind e) { this.value = e.value; }
      public ResolveKind intern() { for (ResolveKind e : values()) if (e.value == value) return e; return this; }
      @Override public String toString() { return intern().name(); }
  }

  /** Type resolution function. Given input types, return output type.  This
   *  function MAY may use the kernel state to decide the output type based on
   *  the FunctionOptions.
   * 
   *  This function SHOULD _not_ be used to check for arity, that is to be
   *  performed one or more layers above. */
  public static class Resolver extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Resolver(Pointer p) { super(p); }
      protected Resolver() { allocate(); }
      private native void allocate();
      public native @ByVal TypeHolderResult call(KernelContext arg0, @StdVector TypeHolder arg1);
  }

  /** \brief Output an exact type */
  public OutputType(@SharedPtr @Cast({"", "std::shared_ptr<arrow::DataType>"}) DataType type) { super((Pointer)null); allocate(type); }
  private native void allocate(@SharedPtr @Cast({"", "std::shared_ptr<arrow::DataType>"}) DataType type);

  /** \brief Output a computed type depending on actual input types */
  public OutputType(Resolver resolver) { super((Pointer)null); allocate(resolver); }
  private native void allocate(Resolver resolver);

  public OutputType(@Const @ByRef OutputType other) { super((Pointer)null); allocate(other); }
  private native void allocate(@Const @ByRef OutputType other);

  public native @ByRef @Name("operator =") OutputType put(@Const @ByRef OutputType arg0);

  /** \brief Return the type of the expected output value of the kernel given
   *  the input argument types. The resolver may make use of state information
   *  kept in the KernelContext. */
  public native @ByVal TypeHolderResult Resolve(KernelContext ctx,
                               @StdVector TypeHolder args);

  /** \brief The exact output value type for the FIXED kind. */
  public native @SharedPtr @Cast({"", "std::shared_ptr<arrow::DataType>"}) DataType type();

  /** \brief For use with COMPUTED resolution strategy. It may be more
   *  convenient to invoke this with OutputType::Resolve returned from this
   *  method. */
  public native Resolver resolver();

  /** \brief Render a human-readable string representation. */
  public native @StdString String ToString();

  /** \brief Return the kind of type resolution of this output type, whether
   *  fixed/invariant or computed by a resolver. */
  public native ResolveKind kind();
}
