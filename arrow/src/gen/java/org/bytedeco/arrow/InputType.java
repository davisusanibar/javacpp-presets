// Targeted by JavaCPP version 1.5.9-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.arrow;

import org.bytedeco.arrow.Function;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

import static org.bytedeco.arrow.global.arrow.*;
  // namespace match

/** \brief An object used for type-checking arguments to be passed to a kernel
 *  and stored in a KernelSignature. The type-checking rule can be supplied
 *  either with an exact DataType instance or a custom TypeMatcher. */
@Namespace("arrow::compute") @NoOffset @Properties(inherit = org.bytedeco.arrow.presets.arrow.class)
public class InputType extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public InputType(Pointer p) { super(p); }

  /** \brief The kind of type-checking rule that the InputType contains. */
  public enum Kind {
    /** \brief Accept any value type. */
    ANY_TYPE(0),

    /** \brief A fixed arrow::DataType and will only exact match having this
     *  exact type (e.g. same TimestampType unit, same decimal scale and
     *  precision, or same nested child types). */
    EXACT_TYPE(1),

    /** \brief Uses a TypeMatcher implementation to check the type. */
    USE_TYPE_MATCHER(2);

      public final int value;
      private Kind(int v) { this.value = v; }
      private Kind(Kind e) { this.value = e.value; }
      public Kind intern() { for (Kind e : values()) if (e.value == value) return e; return this; }
      @Override public String toString() { return intern().name(); }
  }

  /** \brief Accept any value type */
  public InputType() { super((Pointer)null); allocate(); }
  private native void allocate();

  /** \brief Accept an exact value type. */
  public InputType(@SharedPtr @Cast({"", "std::shared_ptr<arrow::DataType>"}) DataType type) { super((Pointer)null); allocate(type); }
  private native void allocate(@SharedPtr @Cast({"", "std::shared_ptr<arrow::DataType>"}) DataType type);

  /** \brief Use the passed TypeMatcher to type check. */
  public InputType(@SharedPtr TypeMatcher type_matcher) { super((Pointer)null); allocate(type_matcher); }
  private native void allocate(@SharedPtr TypeMatcher type_matcher);

  /** \brief Match any type with the given Type::type. Uses a TypeMatcher for
   *  its implementation. */
  public InputType(@Cast("arrow::Type::type") int type_id) { super((Pointer)null); allocate(type_id); }
  private native void allocate(@Cast("arrow::Type::type") int type_id);

  public InputType(@Const @ByRef InputType other) { super((Pointer)null); allocate(other); }
  private native void allocate(@Const @ByRef InputType other);

  public native @Name("operator =") void put(@Const @ByRef InputType other);

  // \brief Match any input (array, scalar of any type)
  public static native @ByVal InputType Any();

  /** \brief Return true if this input type matches the same type cases as the
   *  other. */
  public native @Cast("bool") boolean Equals(@Const @ByRef InputType other);

  public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef InputType other);

  public native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef InputType other);

  /** \brief Return hash code. */
  public native @Cast("size_t") long Hash();

  /** \brief Render a human-readable string representation. */
  public native @StdString String ToString();

  /** \brief Return true if the Datum matches this argument kind in
   *  type (and only allows scalar or array-like Datums). */
  public native @Cast("bool") boolean Matches(@Const @ByRef Datum value);

  /** \brief Return true if the type matches this InputType */
  public native @Cast("bool") boolean Matches(@Const @ByRef DataType type);

  /** \brief The type matching rule that this InputType uses. */
  public native Kind kind();

  /** \brief For InputType::EXACT_TYPE kind, the exact type that this InputType
   *  must match. Otherwise this function should not be used and will assert in
   *  debug builds. */
  public native @SharedPtr @Cast({"", "std::shared_ptr<arrow::DataType>"}) DataType type();

  /** \brief For InputType::USE_TYPE_MATCHER, the TypeMatcher to be used for
   *  checking the type of a value. Otherwise this function should not be used
   *  and will assert in debug builds. */
  public native @Const @ByRef TypeMatcher type_matcher();
}
